= Migrating a JavaEE-6 application from IBM Websphere 8.5.5 to Wildfly 8.1 

by *Paris Apostolopoulous* aka javapapo ( http://javapapo.blogspot.com[blog] | https://twitter.com/javapapo[twitter] | http://gr.linkedin.com/in/javaneze/[linkedIn] | mailto:javapapo@mac.com[email] | http://www.jhug.gr[JUG] )


About this guide
----------------
This guide is about the migration process of a https://jcp.org/en/jsr/detail?id=316[JavaEE 6] enteprise application, developed over the past year based on the
http://www-03.ibm.com/software/products/en/appserv-was[IBM Wesbsphere 8.5.5 Full profile] (a JavaEE6 container) to http://wildfly.org/[Wildfly 8.1.0.Final] (a http://www.oracle.com/technetwork/java/javaee/tech/index.html[JavaEE7] container).

*Disclaimer*: Some of the comments and points raised in the sections below, are based on my personal opinion and experience only while working with JavaEE servers in different application domains. Feel free to comment or correct me and provide additional feedback in any case. 

Basic development principles
-----------------------------
As any software development team  has it's own principles and guidelines in our case we had set some very basic goals and we tried hard to 'achieve' as many as we could during the development cycles. Some of our initial goals (listed below) will
explaion some of 'technical' decision(s) taken. Some others were actually the basis, that enabled us to migrate from platfrom A to platform B. It is vital to the reader to have them in mind prior to going through
the rest of this document, since they explain why we choosed to use this particual tool or this particular technology or vice versa.

* We wanted our development to be based on http://maven.apache.org/[Maven 3] in terms of packaging, configuration and deployment. 
* We wanted to be able to select the http://en.wikipedia.org/wiki/Integrated_development_environment[IDE] of our choice, no matter if it is https://netbeans.org/[Netbeans] / https://www.eclipse.org[Eclipse] / http://www.jetbrains.com/idea/[IntelliJ]. At the same time we wanted to avoid any IDE specific lock-in where teams or developers are loosing control over their configuration and deployment process and start rely on 'specific' plugins and tools build on top of general use IDE(s).
* We wanted to be able to select the operating system we would be developing on, so we would have developers coding on http://en.wikipedia.org/wiki/Linux[Linux], on http://en.wikipedia.org/wiki/Microsoft_Windows[Windows] or http://en.wikipedia.org/wiki/MacOSX[MacOSX] (like me). That is a nice way to eventually catch bugs or application / platform inefficiencies.
* We wanted to control and configure our deployment environment (aka the application server) as much as possible the same way as we did with our application, meaning scripting the application server or manipulating the environment through maven, especially for pre or post deploy tasks.
* We wanted to be as much close to the JavaEE specification API(s) in terms of coding as possible, so that we have a chance on migrating the majority of the code to another container.
* We wanted to layer our application (it was complex anyway) into modules with as much as possible distinctive boundaries in terms of API(s) /responsibilities and library dependencies. Monolithic or crippled modular applications tend to raise more often more problems when being deployed to different containers because each 'big' module has many technical dependencies that needs to be addressed.


It is not easy to fullfil all the above in one go, and some times it might take some more time, following these principles than simple hacking your way around. It turns though that these  guidelines are the basis for starting to think about moving to different deployment enviroments. The hard stuff are the small details behind things like the way you have structured your application, the use of a specific API that is specific to a technology or container, the use of a specific tool on an operating system that binds you with this platform. 

Last but least, a reality that I had to face many times in my carrer, *WE DID NOT* have any paid support subscription either from IBM or RedHat. So my only tools were 

* any previous experience
* http://stackoverflow.com/[stackoverflow]
* support forums and free documentation available e.g https://www.ibm.com/developerworks/community/forums/html/[IBM support forum] or https://community.jboss.org/welcome[Jboss Forums]
* the community 

Application technology stack and frameworks available
----------------------------------------------------
We started with the requirement on developing and deploying towards the latest version of the IBM Wesphere Application Server. At that time (and while I write these lines) the latest version is 8.5.5 which is a JavaEE6 Full Profile Application server. Since we wanted to use all of the JavaEE specification features the use of the new https://developer.ibm.com/wasdev/2013/03/29/introducing_the_liberty_profile/['Liberty'] profile was out of the scope, so we targeted the Full Profile. An older version of the application was already based on a previous version of Websphere (7). 

The main technologies needed  by our application would be the following :

http://www.oracle.com/technetwork/java/javaee/ejb-141389.html[EJB 3.1] | http://docs.oracle.com/javaee/6/tutorial/doc/bnceh.html[JMS] | http://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html[CDI] | http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html[JPA 2.0] | http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html[JAX-RS] 
| http://docs.oracle.com/javaee/6/tutorial/doc/bnaph.html[JSF 2]

The default library/implementations provided by Websphere for some of the technologies above is the following :

http://openwebbeans.apache.org/[OpenWebBeans v 1.1.6 CDI Container] | http://openjpa.apache.org/documentation.html[OpenJPA 2.2.1] | http://wink.apache.org/[Apache Wink - JAX-RS] | http://myfaces.apache.org/[Apache MyFaces 2.0.5]


Diverting from the Websphere tool set and problems
---------------------------------------------------
Please treat this section as constructive critism, I only want to address the problems I faced as a developer who tried to work with a given toolset. You may skip this section as well. 

[cols="<1,<10,<2",options="header"]
|=============================================================================================================================
|Case|Websphere 8.5 | Wildfly 8.1
|OS Availability| No MacOSX support, IBM JDK| OS independent, Sun JDK (MacOSX includded)
|Installation| Installation had to go through a special program, that would download or import huge files containing the app server. You need some time to get started and is not 'scriptable' to set up a server |Installation is easy, you can either download a 127 MB zip or even add a Maven task to download the full server as a dependency, then unpack the server in any custom folder. 


|=============================================================================================================================



*Installation*
One *minor* but long standing difficulties developing towards Websphere is that is not available on all platforms, so those coding on MacOSX where forced to install and deploy on a remote machine (usually an extra windows PC), this is a great difference comparing with Wilfly and previous Jboss application servers where you can run then in any standard JDK supported environment. Another small problem is the installation and deployment of the server, we had to go over installing a specific application that managed the installation and then download a files 2GB of size in order to get a full profile appllication server running.The update and patching was also time and resource consuming. Again downloading a Wildlfly zip of 127 MB is a huge difference.

*Server Configuration Tools*
One of the things that I find difficult to use and easily grasp is the available toolset for configuration after deployment. Websphere follows the same scripting 'engine' principle, very similar to recent versions of http://www.oracle.com/technetwork/middleware/weblogic/overview/index.html[Weblogic], (python or jacl based). Despite the fact that some people especially sys admins find the tools handy, I have to admit that I find them not very easy to use especially for people with no prior experience. The lack of an official Maven plugin was making things even worse (remember our guide lines), and we were left  integrating Ant tasks, called within Maven that were actually calling jars in the classpath of an already installed application server instance. The major problem is that in order to script your way to the development or deployment environment, you had to install a websphere engine on the machine that was going to issue the commands. Again developers with no Websphere supported O/S could not invoke such scripts (there are work-arounds).There is a huge difference in Wildfly where the new https://docs.jboss.org/author/display/WFLY8/CLI+Recipes[CLI] and the official https://docs.jboss.org/wildfly/plugins/maven/latest/[Wildfly Maven plugin], do not impose any of the above restrictions especially OS. 

*Pre / Post deployment settings*
Many application servers use propriatery descriptors in order to control the deployment of enterprise applications. Websphere features a http://pic.dhe.ibm.com/infocenter/rsahelp/v8/index.jsp?topic=%2Fcom.ibm.servertools.doc%2Ftopics%2Fcenhcear.html[handfull] of those depending on the application or module type. I dont think it is bad, all the application servers do it, but it eventually ends up on having to rely on specific tools (IDE, plugins) that are going to 1) create the descriptors, 2) generate automatically the paths within your ear (already aware of your local server deployment). Since we were not using all these specific tools, we were not using any specific files, neither we could eventually manually generate correctly (some of them we could devise them). We were relying on the fact that if we generate a compliant to the specification ear file, any application server should be able to deploy it accordingly. More or less we managed to do this, but there were some that extra configuration was needed.

In comparison Widfly has a smaller set of specific files that control features namely the jboss-deployment-structure.xml.

*Shared libraries and class loaders*
I have spent several hours (or man days) trying to understand the exact way and the exact class path that is being inherited by the Parent class loader of the Websphere application server, and how it affects the deployed application. In cases where you actually dont bundle any extra libraries or frameworks (eventually the applications server class path) you will be ok. In other cases where you wanted to bundle your own implementation for something then it is a matter of how you deploy your jars and if they are going to conflict with any existing jar from parent class loaders.
The only way to make your way through the hierarchical class-loading is to create 'Shared libraries' that will include your preferred jars and then associate them either with the overall application server instance or your specific deployment. This association could be done easily prior to deployment (unless a tool was generating a special descriptor, that was injected to your deployable). This descriptor was very specific to your server. I don't know if the 'Shared library' way and the required pre-post deploy configuration required is 'flexible enough'. We ended up, not to use currently any shared libraries, and structure our EAR + bundled jars that way that they would not conflict with the default PARENT_FIRST and Parent classloading hierarchy of WebSphere. Indeed this is very restrictive and we had problems like the https://hibernate.atlassian.net/browse/HHH-8778[following] when Hibernate decided to use a newer version of Javassist internally and was conflicting with the version that Webpshere is providing.
In comparison Widfly has a far more flexible classloading mechanism, is bundling many 'first' class appilication libraries and is dead easy with 3 lines of xml code, to disable or enable classpath visibility on bundled libraries. I have to admit after this migration process this feature was my favourite of all, since I managed to maintain most of my initial library setup with no major changes. See sections below. 


*We switched and integrated the following replacement technologies*

Hibernate 4.2.7 
Infinispan 6


Java EE specification forward compatibility
-------------------------------------------

Wildfly Configuration Specifics
-------------------------------




